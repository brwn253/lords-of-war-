// ===== LORDS OF WAR - GAME ENGINE =====
// This engine uses CARD_DATABASE and LORDS from lords-of-war.js

// Create HEROES alias for compatibility (engine code uses HEROES internally)
let HEROES = typeof LORDS !== 'undefined' ? LORDS : {};
// HISTORIC_LEADERS is defined as const in lords-of-war.js, we'll reference it from window
// Don't declare it here to avoid redeclaration error

// Game constants
const GAME_CONSTANTS = {
    MAX_BOARD_SIZE: 7,
    MAX_ESSENCE: 10,
    STARTING_HEALTH: 30,
    STARTING_HAND_SIZE: 3,
    TYPE_ADVANTAGE_BONUS: 2
};

// ===== GAME STATE =====

const game = {
    currentPlayer: 'player',
    turnNumber: 1,
    player: {
        hero: null,
        health: GAME_CONSTANTS.STARTING_HEALTH,
        maxEssence: 0,
        currentEssence: 0,
        heroPowerUsed: false,
        deck: [],
        hand: [],
        board: [],
        weapon: null,
        constructsPlayed: 0
    },
    enemy: {
        hero: null,
        health: GAME_CONSTANTS.STARTING_HEALTH,
        maxEssence: 0,
        currentEssence: 0,
        heroPowerUsed: false,
        deck: [],
        hand: [],
        board: [],
        weapon: null,
        constructsPlayed: 0
    },
    targeting: null,
    tempPowerBuff: 0
};

// ===== UTILITY FUNCTIONS =====

function log(message, type = '') {
    const logArea = document.getElementById('gameLog');
    const entry = document.createElement('div');
    entry.className = `log-entry ${type}`;
    entry.textContent = `Turn ${game.turnNumber}: ${message}`;
    logArea.appendChild(entry);
    logArea.scrollTop = logArea.scrollHeight;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function createDeck(heroUnitType = null) {
    const deck = [];
    // Ensure CARD_DATABASE is available
    const cardDatabase = typeof CARD_DATABASE !== 'undefined' ? CARD_DATABASE : 
                   (typeof window.CARD_DATABASE !== 'undefined' ? window.CARD_DATABASE : null);
    
    if (!cardDatabase) {
        console.error('CARD_DATABASE not found!', typeof CARD_DATABASE, typeof window.CARD_DATABASE);
        return deck;
    }

    // Create a balanced deck with units, abilities, and equipment
    const deckList = [];
    
    // Add units based on hero type (ONLY hero's type)
    if (heroUnitType === 'ranged') {
        // Ranged hero: ONLY ranged units
        deckList.push('archer', 'archer', 'archer', 'crossbow', 'crossbow', 'skirmisher', 'skirmisher', 'scout', 'scout');
    } else if (heroUnitType === 'infantry') {
        // Infantry hero: ONLY infantry units
        deckList.push('footman', 'footman', 'footman', 'swordsman', 'swordsman', 'swordsman', 'knight', 'sergeant', 'sergeant');
    } else if (heroUnitType === 'cavalry') {
        // Cavalry hero: ONLY cavalry units
        deckList.push('horseman', 'horseman', 'horseman', 'camelRider', 'camelRider', 'mountedKnight', 'messenger', 'messenger');
    } else {
        // Default mix (equal distribution)
        deckList.push('archer', 'archer', 'crossbow', 'skirmisher', 'skirmisher');
        deckList.push('footman', 'footman', 'swordsman', 'swordsman', 'knight');
        deckList.push('horseman', 'horseman', 'camelRider', 'mountedKnight');
    }
    
    // Add abilities based on hero type (ONLY hero's type abilities)
    if (heroUnitType === 'ranged') {
        deckList.push('quickShot', 'quickShot', 'aimedShot', 'aimedShot', 'masterShot', 'rangersMark', 'bowEnchantment', 'quiverRefill', 'quiverRefill');
    } else if (heroUnitType === 'infantry') {
        deckList.push('quickStrike', 'quickStrike', 'focusStrike', 'focusStrike', 'swordEnchantment', 'shieldWall', 'supplyLine', 'supplyLine');
    } else if (heroUnitType === 'cavalry') {
        deckList.push('quickCharge', 'quickCharge', 'focusCharge', 'focusCharge', 'axeEnchantment', 'cavalryFormation', 'courierNetwork', 'courierNetwork');
    } else {
        // Default mix
        deckList.push('quickShot', 'aimedShot', 'quickStrike', 'focusStrike', 'quickCharge', 'focusCharge');
    }
    
    // Add equipment based on hero type (weapons and armor)
    if (heroUnitType === 'ranged') {
        deckList.push('bow', 'bow');
        // Ranged armor (no shield/back/boots/necklace)
        deckList.push('clothCoif', 'paddedClothArmor', 'paddedClothChaps');
    } else if (heroUnitType === 'infantry') {
        deckList.push('sword', 'sword');
        // Infantry armor (no boots/gloves/necklace/cape)
        deckList.push('plateHelmet', 'plateBody', 'plateLegs', 'kiteShield');
    } else if (heroUnitType === 'cavalry') {
        deckList.push('axe', 'axe');
        // Cavalry armor (no boots/gloves/necklace/cape)
        deckList.push('leatherCap', 'leatherArmor', 'leatherLeggings', 'leatherShield');
    } else {
        // Default: one of each
        deckList.push('bow', 'sword', 'axe');
    }
    
    // Fill to 30 cards with cards matching hero type
    const fillCards = {
        'ranged': ['archer', 'skirmisher', 'quickShot'],
        'infantry': ['footman', 'swordsman', 'quickStrike'],
        'cavalry': ['horseman', 'camelRider', 'quickCharge']
    };
    const fillSet = fillCards[heroUnitType] || ['archer', 'footman', 'horseman'];
    
    while (deckList.length < 30) {
        deckList.push(...fillSet);
    }
    deckList.length = 30; // Trim to exactly 30

    deckList.forEach(cardId => {
        const cardData = cardDatabase[cardId];
        if (cardData) {
            // Deep copy
            const cardCopy = { ...cardData };
            deck.push(cardCopy);
        } else {
            console.warn('Card not found in database:', cardId);
        }
    });

    return shuffleArray(deck);
}

function drawCard(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    if (playerData.deck.length === 0) {
        log(`${player} has no cards left to draw!`, player);
        return null;
    }

    const card = playerData.deck.pop();
    card.justDrawn = true; // Mark for animation
    playerData.hand.push(card);
    log(`${player} drew a card`, player);

    updateUI();
    return card;
}

// ===== GAME INITIALIZATION =====

function chooseUnitType(unitType) {
    // Get HISTORIC_LEADERS from window (defined in lords-of-war.js)
    const HISTORIC_LEADERS = window.HISTORIC_LEADERS || {};
    
    // Show hero selection for chosen type
    const leaders = HISTORIC_LEADERS[unitType] || [];
    if (leaders.length < 2) {
        console.error('Error: Not enough leaders for this type', unitType, HISTORIC_LEADERS);
        alert('Error: Not enough leaders for this type. Available: ' + Object.keys(HISTORIC_LEADERS).join(', '));
        return;
    }
    
    // Pick 2 random leaders
    const shuffled = [...leaders].sort(() => Math.random() - 0.5);
    const options = [shuffled[0], shuffled[1]];
    
    // Show selection modal
    showHeroSelection(unitType, options);
}

function showHeroSelection(unitType, options) {
    const modal = document.getElementById('gameStartModal');
    if (!modal) {
        console.error('gameStartModal element not found!');
        return;
    }
    modal.classList.remove('hidden');
    modal.innerHTML = `
        <h1>‚öîÔ∏è Choose Your Leader ‚öîÔ∏è</h1>
        <p>Select one of these ${unitType} commanders:</p>
        <div style="display: flex; gap: 20px; justify-content: center; margin: 20px 0;">
            ${options.map((hero, idx) => `
                <button onclick="selectHero('${hero.id}')" style="padding: 20px; min-width: 200px;">
                    <div style="font-size: 24px; font-weight: bold;">${hero.name}</div>
                    <div style="font-size: 14px; margin-top: 10px;">${hero.passive || ''}</div>
                    <div style="font-size: 12px; margin-top: 5px; color: #2a1810; font-weight: bold;">${hero.commandName}: ${hero.commandText}</div>
                </button>
            `).join('')}
        </div>
        <button onclick="showUnitTypeSelection()" style="margin-top: 20px;">‚Üê Back</button>
    `;
}

function showUnitTypeSelection() {
    const modal = document.getElementById('gameStartModal');
    if (!modal) {
        console.error('gameStartModal element not found!');
        return;
    }
    modal.classList.remove('hidden');
    modal.innerHTML = `
        <h1>‚öîÔ∏è Lords of War ‚öîÔ∏è</h1>
        <p>Choose Your Unit Type:</p>
        <button onclick="chooseUnitType('ranged')" style="padding: 20px 40px; margin: 10px;">
            üèπ Ranged
        </button>
        <button onclick="chooseUnitType('infantry')" style="padding: 20px 40px; margin: 10px;">
            üõ°Ô∏è Infantry
        </button>
        <button onclick="chooseUnitType('cavalry')" style="padding: 20px 40px; margin: 10px;">
            üêé Cavalry
        </button>
    `;
}

function selectHero(heroId) {
    startGame(heroId);
}

// Make functions available globally immediately after definition
if (typeof window !== 'undefined') {
    window.chooseUnitType = chooseUnitType;
    window.selectHero = selectHero;
    window.showUnitTypeSelection = showUnitTypeSelection;
}

function startGame(heroId) {
    // Get data from window (defined in lords-of-war.js)
    const HISTORIC_LEADERS = window.HISTORIC_LEADERS || {};
    const CARD_DATABASE = window.CARD_DATABASE || {};
    
    // Find hero in HISTORIC_LEADERS
    let heroData = null;
    for (const type in HISTORIC_LEADERS) {
        const hero = HISTORIC_LEADERS[type].find(h => h.id === heroId);
        if (hero) {
            heroData = hero;
            break;
        }
    }
    
    if (!heroData) {
        console.error('Hero not found:', heroId);
        console.error('Available leaders:', HISTORIC_LEADERS);
        alert('Error: Hero not found. Please refresh the page.');
        return;
    }
    
    // Use the global CARD_DATABASE for deck creation
    const cardDB = window.CARD_DATABASE || {};

    // Set player hero
    game.player.hero = heroData;
    game.player.health = heroData.health;
    game.player.deck = createDeck(heroData.unitType);
    game.player.hand = [];
    game.player.equipment = null;
    game.player.equipmentUsed = false;
    game.player.equipmentSlots = {
        weapon: null,
        head: null,
        chest: null,
        legs: null,
        shield: null,
        boots: null
    };
    game.player.maxHealth = 30;

    // Set enemy hero (random different type)
    const enemyTypes = Object.keys(HISTORIC_LEADERS).filter(t => t !== heroData.unitType);
    const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    const enemyLeaders = HISTORIC_LEADERS[enemyType] || [];
    const enemyHero = enemyLeaders[Math.floor(Math.random() * enemyLeaders.length)];
    
    game.enemy.hero = enemyHero;
    game.enemy.health = game.enemy.hero.health;
    game.enemy.deck = createDeck(enemyHero.unitType);
    game.enemy.hand = [];
    game.enemy.equipment = null;
    game.enemy.equipmentUsed = false;
    game.enemy.equipmentSlots = {
        weapon: null,
        head: null,
        chest: null,
        legs: null,
        shield: null,
        boots: null
    };
    game.enemy.maxHealth = 30;

    // Hide modal
    document.getElementById('gameStartModal').classList.add('hidden');

    // Draw starting hands
    for (let i = 0; i < 3; i++) {
        drawCard('player');
        drawCard('enemy');
    }

    log('Game started!');
    log(`Player chose ${heroData.name} (${heroData.unitType})`);
    log(`Enemy is ${game.enemy.hero.name} (${game.enemy.hero.unitType})`);

    startTurn('player');
    updateUI();

    // Setup hand scroll buttons
    const prevBtn = document.getElementById('handPrevBtn');
    const nextBtn = document.getElementById('handNextBtn');
    if (prevBtn) prevBtn.onclick = scrollHandPrev;
    if (nextBtn) nextBtn.onclick = scrollHandNext;
}

// Functions will be made global after they're defined (see end of file)

function startTurn(player) {
    game.currentPlayer = player;
    const playerData = player === 'player' ? game.player : game.enemy;

    // Increment essence/gold
    if (playerData.maxEssence < GAME_CONSTANTS.MAX_ESSENCE) {
        playerData.maxEssence++;
    }
    playerData.currentEssence = playerData.maxEssence;

    // Reset hero power and equipment
    playerData.heroPowerUsed = false;
    playerData.equipmentUsed = false;
    
    // Initialize equipment slots if not present
    if (!playerData.equipmentSlots) {
        playerData.equipmentSlots = {
            weapon: null,
            head: null,
            chest: null,
            legs: null,
            shield: null,
            boots: null
        };
    }
    if (!playerData.maxHealth) {
        playerData.maxHealth = 30;
    }

    // Refresh constructs
    playerData.board.forEach(construct => {
        construct.canAttack = true;
        construct.exhausted = false;
    });

    // Reset temp buffs
    game.tempPowerBuff = 0;
    playerData.constructsPlayed = 0;

    // Draw card
    drawCard(player);

    log(`${player}'s turn ${game.turnNumber} begins`, player);

    // Show turn indicator
    showTurnIndicator(player);

    updateUI();

    // AI turn
    if (player === 'enemy') {
        setTimeout(() => playAITurn(), 1500);
    }
}

function showTurnIndicator(player) {
    const indicator = document.createElement('div');
    indicator.className = 'turn-indicator';
    indicator.textContent = player === 'player' ? 'YOUR TURN' : 'ENEMY TURN';
    indicator.style.color = player === 'player' ? '#4ecdc4' : '#ff6b6b';
    document.body.appendChild(indicator);

    setTimeout(() => {
        indicator.remove();
    }, 2000);
}

function hasAvailableMoves(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    
    // Check for playable cards
    const playableCards = playerData.hand.filter(card => canPlayCard(card, player));
    if (playableCards.length > 0) return true;
    
    // Check for units that can attack
    const attackableUnits = playerData.board.filter(c => c.canAttack && !c.exhausted);
    if (attackableUnits.length > 0) return true;
    
    // Check for equipment attack
    if (playerData.equipment && !playerData.equipmentUsed) return true;
    
    // Check for hero power (if equipment is equipped)
    if (playerData.equipment && !playerData.equipmentUsed) return true;
    
    return false;
}

function showEndTurnConfirmation() {
    // Create confirmation modal
    const modal = document.createElement('div');
    modal.className = 'confirmation-modal';
    modal.id = 'endTurnConfirmation';
    modal.innerHTML = `
        <h3>‚ö†Ô∏è End Turn? ‚ö†Ô∏è</h3>
        <p>You still have moves available:</p>
        <ul style="text-align: left; color: #f4e4c1; margin: 20px 0; padding-left: 40px;">
            ${game.player.hand.filter(c => canPlayCard(c, 'player')).length > 0 ? '<li>Playable cards in hand</li>' : ''}
            ${game.player.board.filter(c => c.canAttack && !c.exhausted).length > 0 ? '<li>Units that can attack</li>' : ''}
            ${game.player.equipment && !game.player.equipmentUsed ? '<li>Equipment attack available</li>' : ''}
        </ul>
        <p>Are you sure you want to end your turn?</p>
        <div class="button-group">
            <button class="confirm" onclick="confirmEndTurn()">Yes, End Turn</button>
            <button class="cancel" onclick="cancelEndTurn()">Cancel</button>
        </div>
    `;
    document.body.appendChild(modal);
}

function confirmEndTurn() {
    const modal = document.getElementById('endTurnConfirmation');
    if (modal) {
        modal.remove();
    }
    actuallyEndTurn();
}

function cancelEndTurn() {
    const modal = document.getElementById('endTurnConfirmation');
    if (modal) {
        modal.remove();
    }
}

function actuallyEndTurn() {
    log(`${game.currentPlayer} ended their turn`, game.currentPlayer);

    if (game.currentPlayer === 'player') {
        game.turnNumber++;
        startTurn('enemy');
    } else {
        startTurn('player');
    }
}

function endTurn() {
    if (game.targeting) {
        log('Cancel targeting first');
        return;
    }

    // Check for available moves and show confirmation modal
    if (game.currentPlayer === 'player' && hasAvailableMoves('player')) {
        showEndTurnConfirmation();
        return;
    }

    actuallyEndTurn();
}

// ===== CARD PLAYING =====

function canPlayCard(card, player) {
    const playerData = player === 'player' ? game.player : game.enemy;

    if (!card || typeof card.cost !== 'number') {
        return false; // Card must have a valid cost
    }

    // Check essence cost
    let cost = card.cost;

    // Shadow Blade passive: first tactic costs 1 less
    if (playerData.hero && playerData.hero.id === 'shadowBlade' && card.type === 'tactic' && playerData.constructsPlayed === 0) {
        cost = Math.max(0, cost - 1);
    }

    if (playerData.currentEssence < cost) {
        return false;
    }

    // Check board space for units/constructs (equipment doesn't need board space)
    if (card.type === 'unit' || card.type === 'construct') {
        if (playerData.board.length >= GAME_CONSTANTS.MAX_BOARD_SIZE) {
            return false;
        }
    }

    return true;
}

function playCard(card, player, target = null) {
    const playerData = player === 'player' ? game.player : game.enemy;

    if (!canPlayCard(card, player)) {
        log('Cannot play that card', player);
        return false;
    }

    // Calculate cost
    let cost = card.cost;
    if (playerData.hero && playerData.hero.id === 'shadowBlade' && card.type === 'tactic' && playerData.constructsPlayed === 0) {
        cost = Math.max(0, cost - 1);
    }

    // Pay essence
    playerData.currentEssence -= cost;

    log(`${player} played ${card.name}`, player);

    // Handle card type - some types handle hand removal themselves (like combine)
    let cardHandledRemoval = false;
    if (card.type === 'construct' || card.type === 'unit') {
        // Check if this will combine (before removing from hand)
        const cardTier = card.tier || 1;
        const existingCard = playerData.board.find(c => c.id === card.id && (c.tier || 1) === cardTier);
        if (existingCard) {
            // Will combine - playConstruct will handle hand removal
            cardHandledRemoval = true;
        }
    }

    // Remove from hand only if not handled by the play function
    if (!cardHandledRemoval) {
        const handIndex = playerData.hand.findIndex(c => 
            c.id === card.id && 
            (c.tier || 1) === (card.tier || 1) &&
            (!card.instanceId || c.instanceId === card.instanceId)
        );
        if (handIndex >= 0) {
            playerData.hand.splice(handIndex, 1);
        }
    }

    // Handle card type
    if (card.type === 'construct' || card.type === 'unit') {
        playConstruct(card, player);
    } else if (card.type === 'technique' || card.type === 'tactic' || card.type === 'ability') {
        playTechnique(card, player, target);
    } else if (card.type === 'forge' || card.type === 'equipment') {
        playForge(card, player, target);
    }

    // Trigger resonance effects
    triggerResonance(player);

    updateUI();
    return true;
}

function playConstruct(card, player) {
    const playerData = player === 'player' ? game.player : game.enemy;

    // Check for combine mechanic: if same card ID exists on board with same tier, merge them
    const cardTier = card.tier || 1; // Default tier 1 for base cards
    const existingCard = playerData.board.find(c => c.id === card.id && (c.tier || 1) === cardTier);
    
    if (existingCard) {
        // Combine the cards - create next tier
        const existingTier = existingCard.tier || 1;
        const newTier = existingTier + 1;
        const combinedPower = (existingCard.power || 0) + (card.power || 0);
        const combinedDurability = (existingCard.durability || 0) + (card.durability || 0);
        const combinedCost = Math.round(card.cost * 1.5);
        
        // Remove existing card from board
        const existingIndex = playerData.board.findIndex(c => c.instanceId === existingCard.instanceId);
        if (existingIndex >= 0) {
            playerData.board.splice(existingIndex, 1);
        }
        
        // Remove the card being played from hand (if it's still there)
        const handIndex = playerData.hand.findIndex(c => 
            c.id === card.id && 
            (c.tier || 1) === (card.tier || 1) &&
            (!card.instanceId || c.instanceId === card.instanceId)
        );
        if (handIndex >= 0) {
            playerData.hand.splice(handIndex, 1);
        }
        
        // Create combined card and add to hand
        const combinedCard = {
            ...card,
            power: combinedPower,
            durability: combinedDurability,
            cost: combinedCost,
            tier: newTier,
            text: card.text || '',
            combined: true // Flag to indicate this is a combined card
        };
        
        playerData.hand.push(combinedCard);
        log(`${card.name} Tier ${existingTier} merged! New Tier ${newTier}: ${combinedPower}/${combinedDurability} (Cost: ${combinedCost})`, player);
        
        updateUI();
        return;
    }

    // Create construct instance
    // All units are exhausted when played (except charge units can attack immediately)
    const hasCharge = card.keywords && card.keywords.includes('charge');
    const construct = {
        ...card,
        type: 'construct', // Normalize type
        tier: card.tier || 1, // Preserve tier (default 1)
        canAttack: hasCharge || 
                   (playerData.hero && playerData.hero.id === 'swiftRider' && card.cost <= 3),
        exhausted: !hasCharge, // Exhausted unless it has charge
        instanceId: Date.now() + Math.random()
    };

    // Mountain King passive: Protection on 5+ durability
    if (playerData.hero && playerData.hero.id === 'mountainKing' && construct.durability >= 5) {
        if (!construct.keywords) construct.keywords = [];
        if (!construct.keywords.includes('protection')) {
            construct.keywords.push('protection');
        }
    }

    // Apply type advantage bonus when unit is played
    if (construct.unitType === 'ranged') {
        const enemyData = player === 'player' ? game.enemy : game.player;
        const hasEnemyInfantry = enemyData.board.some(c => c.unitType === 'infantry');
        if (hasEnemyInfantry) {
            construct.power += 1;
            log(`${construct.name} gained +1 attack against infantry units`);
        }
    }

    playerData.board.push(construct);

    // Trigger Formation keyword
    playerData.board.forEach(c => {
        if (c.keywords && c.keywords.includes('formation') && c.instanceId !== construct.instanceId) {
            c.power += 1;
            log(`${c.name} gained +1/+0 from Formation`);
        }
    });

    // Trigger card draw effects when unit is played
    if (construct.scoutEffect || construct.commandEffect || construct.dispatchEffect) {
        drawCard(player);
        log(`${construct.name} drew a card!`, player);
    }

    playerData.constructsPlayed++;
}

function playTechnique(card, player, target) {
    const playerData = player === 'player' ? game.player : game.enemy;

    // Handle ability cards
    if (card.type === 'ability') {
        const damageType = card.damageType;
        const damageAmount = card.id.includes('quick') ? 1 :
                             (card.id.includes('master') ? 4 :
                             (card.id.includes('focus') || card.id.includes('aimed') ? 3 : 0));
        
        if (damageAmount > 0) {
            if (card.id.includes('quick') && !card.needsTarget) {
                // Random target
                const enemyBoard = player === 'player' ? game.enemy.board : game.player.board;
                const enemyData = player === 'player' ? game.enemy : game.player;

                if (enemyBoard.length > 0) {
                    const randomTarget = enemyBoard[Math.floor(Math.random() * enemyBoard.length)];
                    dealDamage(randomTarget, damageAmount, player);
                } else {
                    damageHero(enemyData, damageAmount, player);
                }
            } else if (target) {
                if (target.type === 'unit' || target.type === 'construct') {
                    dealDamage(target, damageAmount, player);
                } else {
                    const enemyData = player === 'player' ? game.enemy : game.player;
                    damageHero(enemyData, damageAmount, player);
                }

                // Master Shot draws a card
                if (card.id === 'masterShot') {
                    drawCard(player);
                    log(`${card.name} drew a card!`, player);
                }
            }
        } else if (card.id.includes('Mark') || card.id.includes('Formation') || card.id.includes('Wall')) {
            // Buff cards
            if (target && (target.type === 'unit' || target.type === 'construct')) {
                if (card.id.includes('Mark') || card.id.includes('Formation')) {
                    target.power += 2;
                    target.durability += 2;
                    log(`${target.name} gained +2/+2`);
                } else if (card.id.includes('Wall')) {
                    target.durability += 2;
                    log(`${target.name} gained +0/+2`);
                }
            }
        } else if (card.id.includes('Enchantment')) {
            // Permanent enchantments
            const equipType = card.unitType;
            const allCards = [...playerData.hand, ...playerData.board, ...playerData.deck];
            if (playerData.equipment && playerData.equipment.equipType === equipType) {
                playerData.equipment.attackPower = (playerData.equipment.attackPower || 2) + 1;
                log(`All ${equipType} equipment gained +1 attack permanently`);
            }
            allCards.forEach(c => {
                if (c.type === 'equipment' && c.equipType === equipType) {
                    c.attackPower = (c.attackPower || 2) + 1;
                }
            });
            log(`All ${equipType} equipment in deck, hand, and board gained +1 attack!`);
        } else if (card.id === 'quiverRefill' || card.id === 'supplyLine' || card.id === 'courierNetwork') {
            // Draw 3 cards
            for (let i = 0; i < 3; i++) {
                drawCard(player);
            }
            log(`${card.name}: Drew 3 cards!`, player);
        }
    }
}

function playForge(card, player, target) {
    const playerData = player === 'player' ? game.player : game.enemy;

    // Equipment attaches to hero
    if (card.type === 'equipment') {
        // Ensure equipmentSlots exists
        if (!playerData.equipmentSlots) {
            playerData.equipmentSlots = {
                weapon: null,
                head: null,
                chest: null,
                legs: null,
                shield: null,
                boots: null
            };
        }
        
        const equipSlot = card.equipSlot || 'weapon';
        
        // Handle weapon equipment (legacy support)
        if (equipSlot === 'weapon') {
            // If weapon already exists, add attack power instead of replacing
            if (playerData.equipmentSlots.weapon) {
                const newAttackPower = (playerData.equipmentSlots.weapon.attackPower || 2) + (card.attackPower || 2);
                playerData.equipmentSlots.weapon.attackPower = newAttackPower;
                // Legacy support
                playerData.equipment = playerData.equipmentSlots.weapon;
                log(`${player} enhanced ${playerData.equipmentSlots.weapon.name} with ${card.name}! Attack increased to ${newAttackPower}`);
            } else {
                playerData.equipmentSlots.weapon = {
                    ...card,
                    attackPower: card.attackPower || 2,
                    equipType: card.equipType || card.unitType
                };
                // Legacy support
                playerData.equipment = playerData.equipmentSlots.weapon;
                log(`${player} equipped ${card.name} to their hero`);
            }
        } else {
            // Handle armor equipment
            if (playerData.equipmentSlots[equipSlot]) {
                log(`${player} replaced ${playerData.equipmentSlots[equipSlot].name} with ${card.name}`, player);
            }
            playerData.equipmentSlots[equipSlot] = {
                ...card,
                armorValue: card.armorValue || 0
            };
            log(`${player} equipped ${card.name} (${equipSlot})`, player);
            
            // Update hero max health based on armor
            updateHeroMaxHealth(player);
        }
        updateUI();
    }
}

function updateHeroMaxHealth(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    let armorBonus = 0;
    
    // Sum all armor values
    Object.values(playerData.equipmentSlots).forEach(equip => {
        if (equip && equip.armorValue) {
            armorBonus += equip.armorValue;
        }
    });
    
    // Base health is 30, armor adds to max health
    const newMaxHealth = 30 + armorBonus;
    const oldMaxHealth = playerData.maxHealth || 30;
    const healthIncrease = newMaxHealth - oldMaxHealth;
    
    if (healthIncrease !== 0) {
        playerData.maxHealth = newMaxHealth;
        playerData.health += healthIncrease; // Add the difference to current health
        if (healthIncrease > 0) {
            log(`${player} gained ${healthIncrease} health from armor!`, player);
        } else {
            log(`${player} lost ${Math.abs(healthIncrease)} health from armor change`, player);
        }
    }
}

function triggerResonance(player) {
    const playerData = player === 'player' ? game.player : game.enemy;

    playerData.board.forEach(construct => {
        if (construct.keywords && construct.keywords.includes('resonance') && construct.resonanceEffect) {
            construct.resonanceEffect(game);
        }
    });
}

// ===== COMBAT =====

// Unit type counter system
// Infantry counters Cavalry
// Ranged counters Infantry
// Cavalry counters Ranged
function getTypeAdvantage(attacker, defender) {
    if (!attacker.unitType || !defender.unitType) return 0;

    const counters = {
        'infantry': 'cavalry',
        'ranged': 'infantry',
        'cavalry': 'ranged'
    };

    // Ranged advantage is applied at play time, so don't apply it again during combat
    // Only apply other type advantages during combat
    if (attacker.unitType === 'ranged' && defender.unitType === 'infantry') {
        return 0; // Already applied at play time
    }

    // Attacker has advantage
    if (counters[attacker.unitType] === defender.unitType) {
        return GAME_CONSTANTS.TYPE_ADVANTAGE_BONUS; // +2 damage bonus
    }

    // Defender has advantage (attacker is countered)
    if (counters[defender.unitType] === attacker.unitType) {
        return -GAME_CONSTANTS.TYPE_ADVANTAGE_BONUS; // -2 damage penalty
    }

    return 0; // No advantage
}

function getUnitTypeIcon(unitType) {
    switch(unitType) {
        case 'infantry': return 'üõ°Ô∏è';
        case 'ranged': return 'üèπ';
        case 'cavalry': return 'üêé';
        default: return '';
    }
}

function attack(attacker, target, attackerPlayer) {
    if (!attacker.canAttack) {
        log('That construct cannot attack yet');
        return false;
    }

    const attackerData = attackerPlayer === 'player' ? game.player : game.enemy;
    const defenderPlayer = attackerPlayer === 'player' ? 'enemy' : 'player';
    const defenderData = defenderPlayer === 'player' ? game.player : game.enemy;

    log(`${attacker.name} attacks ${target.name || 'Commander'}`, attackerPlayer);

    // Check for weapon effects
    if (attackerData.weapon && attackerData.weapon.id === 'battleAxe') {
        const enemyBoard = attackerPlayer === 'player' ? game.enemy.board : game.player.board;
        enemyBoard.forEach(construct => {
            dealDamage(construct, 1, attackerPlayer);
        });
        if (attackerData.weapon.currentUses !== undefined) {
            attackerData.weapon.currentUses--;
            if (attackerData.weapon.currentUses <= 0) {
                attackerData.weapon = null;
                log('Battle Axe destroyed');
            }
        }
    }

    if (target.type === 'construct' || target.type === 'unit') {
        // Unit vs Unit - RANGED NO HITBACK, MELEE HITS BACK
        const weaponBonus = attackerData.weapon ? attackerData.weapon.equipPower || 0 : 0;
        const typeAdvantage = getTypeAdvantage(attacker, target);
        let attackerPower = attacker.power + weaponBonus + typeAdvantage;
        // Ensure minimum damage of 1
        attackerPower = Math.max(1, attackerPower);
        const defenderPower = target.power;
        const isRangedAttacker = attacker.unitType === 'ranged';
        const isRangedDefender = target.unitType === 'ranged';

        // Log type advantage
        if (typeAdvantage > 0) {
            log(`‚öîÔ∏è TYPE ADVANTAGE! ${getUnitTypeIcon(attacker.unitType)} counters ${getUnitTypeIcon(target.unitType)} (+${typeAdvantage} damage)`, attackerPlayer);
        } else if (typeAdvantage < 0) {
            log(`‚ö†Ô∏è TYPE DISADVANTAGE! ${getUnitTypeIcon(target.unitType)} counters ${getUnitTypeIcon(attacker.unitType)} (${typeAdvantage} damage)`, attackerPlayer);
        }

        // Check for Protection/Ward
        if (target.keywords && (target.keywords.includes('ward') || target.keywords.includes('protection'))) {
            target.keywords = target.keywords.filter(k => k !== 'ward' && k !== 'protection');
            log(`${target.name}'s Protection blocked the attack`);
        } else {
            // Deal damage to target
            target.durability -= attackerPower;
            log(`${attacker.name} dealt ${attackerPower} damage to ${target.name}`);
            
            // Hit back logic: Ranged units don't take hitback, but ranged defenders always hit back
            // Melee units always hit back if attacked
            if (!isRangedAttacker && !isRangedDefender) {
                // Melee vs Melee: both hit back
                attacker.durability -= defenderPower;
                log(`${target.name} hit back for ${defenderPower} damage`);
            } else if (isRangedAttacker && !isRangedDefender) {
                // Ranged attacker vs Melee defender: ranged attacker doesn't take hitback
                // (Melee defender wants to hit back but ranged ignores it)
                log(`${target.name} tried to hit back but ranged ${attacker.name} evaded`);
            } else if (!isRangedAttacker && isRangedDefender) {
                // Melee attacker vs Ranged defender: ranged defender ALWAYS hits back
                attacker.durability -= defenderPower;
                log(`${target.name} hit back for ${defenderPower} damage`);
            } else {
                // Ranged vs Ranged: ranged defender still hits back
                attacker.durability -= defenderPower;
                log(`${target.name} hit back for ${defenderPower} damage`);
            }

            // Check for deaths
            if (target.durability <= 0) {
                destroyConstruct(target, defenderPlayer);
            }
            if (attacker.durability <= 0) {
                destroyConstruct(attacker, attackerPlayer);
            }
        }
    } else {
        // Unit vs Hero - ranged attacks don't hit back, melee do
        const isRanged = attacker.unitType === 'ranged';
        const damage = attacker.power + (attackerData.weapon ? attackerData.weapon.equipPower || 0 : 0);
        
        damageHero(defenderData, damage, attackerPlayer);
        
        // Melee attacks from units hit back (hero counter-attacks)
        // Ranged attacks don't trigger hit back
        if (!isRanged && defenderData.health > 0) {
            const heroCounterDamage = 1; // Hero always hits back for 1 when attacked by melee
            attacker.durability -= heroCounterDamage;
            log(`${defenderData.hero.name} hit back for ${heroCounterDamage} damage`);
            
            if (attacker.durability <= 0) {
                destroyConstruct(attacker, attackerPlayer);
            }
        }
    }

    attacker.canAttack = false;
    attacker.exhausted = true;

    updateUI();
    checkWinCondition();
    return true;
}

function dealDamage(target, amount, sourcePlayer) {
    if (target.keywords && (target.keywords.includes('ward') || target.keywords.includes('protection'))) {
        target.keywords = target.keywords.filter(k => k !== 'ward' && k !== 'protection');
        log(`${target.name}'s Protection blocked ${amount} damage`);
        return;
    }

    target.durability -= amount;
    log(`${target.name} took ${amount} damage`);

    if (target.durability <= 0) {
        const owner = game.player.board.includes(target) ? 'player' : 'enemy';
        destroyConstruct(target, owner);
    }
}

function damageHero(heroData, amount, sourcePlayer) {
    heroData.health -= amount;
    log(`Forgemaster took ${amount} damage`, heroData === game.player ? 'player' : 'enemy');
    updateUI();
    checkWinCondition();
}

function destroyConstruct(construct, owner) {
    log(`${construct.name} was destroyed`, owner);

    // Trigger Reckless keyword
    if (construct.keywords && construct.keywords.includes('reckless') && construct.recklessAmount) {
        const enemyPlayer = owner === 'player' ? 'enemy' : 'player';
        const enemyData = enemyPlayer === 'player' ? game.player : game.enemy;
        const enemyBoard = enemyPlayer === 'player' ? game.player.board : game.enemy.board;
        if (enemyBoard.length > 0) {
            const randomTarget = enemyBoard[Math.floor(Math.random() * enemyBoard.length)];
            dealDamage(randomTarget, construct.recklessAmount, owner);
        } else {
            damageHero(enemyData, construct.recklessAmount, owner);
        }
        log(`Reckless dealt ${construct.recklessAmount} damage`);
    }

    // Add destroy animation
    const boardId = owner === 'player' ? 'playerBoard' : 'enemyBoard';
    const boardEl = document.getElementById(boardId);
    if (boardEl) {
        const cardEls = boardEl.querySelectorAll('.card');
        cardEls.forEach(cardEl => {
            if (cardEl._cardData && cardEl._cardData.instanceId === construct.instanceId) {
                cardEl.classList.add('card-destroy-animation');
            }
        });
    }

    // Remove from board after animation
    setTimeout(() => {
        const ownerData = owner === 'player' ? game.player : game.enemy;
        const index = ownerData.board.findIndex(c => c.instanceId === construct.instanceId);
        if (index >= 0) ownerData.board.splice(index, 1);

        updateUI();
    }, 500); // Match animation duration
}

// ===== HERO POWERS =====

function useHeroPower(player, target = null) {
    const playerData = player === 'player' ? game.player : game.enemy;
    const hero = playerData.hero;

    if (!hero) return false;

    // Hero power requires equipment to be equipped
    if (!playerData.equipment) {
        log('Hero needs a weapon equipped to attack', player);
        return false;
    }

    // Use equipment attack instead (hero power is now equipment-only)
    return useEquipmentAttack(player, target);
}

function useEquipmentAttack(player, target = null) {
    const playerData = player === 'player' ? game.player : game.enemy;
    
    // Check weapon slot (legacy support for equipment)
    const weapon = (playerData.equipmentSlots && playerData.equipmentSlots.weapon) || playerData.equipment;
    
    if (!weapon) {
        log('No weapon equipped', player);
        return false;
    }
    
    if (playerData.equipmentUsed) {
        log('Equipment already used this turn', player);
        return false;
    }
    
    if (!target) {
        // Need to select target
        game.targeting = { mode: 'equipment', player };
        startEquipmentTargeting(player);
        return false;
    }
    
    const damage = weapon.attackPower || 2;
    const damageType = weapon.equipType;
    
    if (target.type === 'unit' || target.type === 'construct') {
        // Equipment attack on unit - melee hits back
        if (damageType !== 'ranged') {
            // Melee: both take damage
            dealDamage(target, damage, player);
            const counterDamage = target.power || 1;
            playerData.health -= counterDamage;
            log(`${target.name} hit back for ${counterDamage} damage`);
        } else {
            // Ranged: no hit back
            dealDamage(target, damage, player);
        }
    } else {
        // Equipment attack on hero
        const enemyData = player === 'player' ? game.enemy : game.player;
        damageHero(enemyData, damage, player);
        
        // Melee equipment hits back (hero counter-attacks)
        if (damageType !== 'ranged' && enemyData.health > 0) {
            const counterDamage = 1; // Hero always hits back for 1
            playerData.health -= counterDamage;
            log(`${enemyData.hero.name} hit back for ${counterDamage} damage`);
            checkWinCondition();
        }
    }
    
    playerData.equipmentUsed = true;
    updateUI();
    checkWinCondition();
    return true;
}

function startEquipmentTargeting(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    const weapon = (playerData.equipmentSlots && playerData.equipmentSlots.weapon) || playerData.equipment;
    const equipType = weapon ? weapon.equipType : null;
    
    document.body.classList.add('targeting');
    log('Select target for equipment attack...', player);
    
    // Can target any enemy
    const enemyBoard = document.getElementById('enemyBoard');
    if (enemyBoard) {
        const constructEls = enemyBoard.querySelectorAll('.card');
        constructEls.forEach(el => {
            if (el._cardData) {
                el.classList.add('valid-target');
                el.onclick = () => {
                    if (game.targeting && game.targeting.mode === 'equipment') {
                        useEquipmentAttack(player, el._cardData);
                        cancelTargeting();
                    }
                };
            }
        });
    }
    
    const enemyHero = document.getElementById('enemyLord');
    if (enemyHero) {
        enemyHero.classList.add('valid-target');
        enemyHero.onclick = () => {
            if (game.targeting && game.targeting.mode === 'equipment') {
                useEquipmentAttack(player, { type: 'hero', name: 'Enemy' });
                cancelTargeting();
            }
        };
    }
}

// ===== AI =====

function playAITurn() {
    const ai = game.enemy;

    // Play cards (with safety limit)
    let cardsPlayed = 0;
    let lastHandSize = ai.hand.length;
    while (cardsPlayed < 10 && ai.hand.length > 0) {
        const playableCards = ai.hand.filter(card => canPlayCard(card, 'enemy'));
        if (playableCards.length === 0) break;

        // Prioritize units/constructs
        const construct = playableCards.find(c => c.type === 'construct' || c.type === 'unit');
        if (construct) {
            playCard(construct, 'enemy');
            cardsPlayed++;
            // Safety check: if hand size didn't change, break to avoid infinite loop
            if (ai.hand.length === lastHandSize) break;
            lastHandSize = ai.hand.length;
            continue;
        }

        // Play tactics/techniques without targets
        const technique = playableCards.find(c => (c.type === 'technique' || c.type === 'tactic') && !c.needsTarget);
        if (technique) {
            playCard(technique, 'enemy');
            cardsPlayed++;
            if (ai.hand.length === lastHandSize) break;
            lastHandSize = ai.hand.length;
            continue;
        }

        break;
    }

    // Attack with all constructs
    setTimeout(() => {
        ai.board.forEach((construct, index) => {
            setTimeout(() => {
                if (construct.canAttack && !construct.exhausted) {
                    // Check for guards/defend
                    const guards = game.player.board.filter(c => 
                        c.keywords && (c.keywords.includes('guard') || c.keywords.includes('defend'))
                    );
                    if (guards.length > 0) {
                        attack(construct, guards[0], 'enemy');
                    } else if (game.player.board.length > 0 && Math.random() < 0.3) {
                        // 30% chance to attack construct
                        const target = game.player.board[Math.floor(Math.random() * game.player.board.length)];
                        attack(construct, target, 'enemy');
                    } else {
                        // Attack face
                        attack(construct, { name: 'Player', type: 'hero' }, 'enemy');
                    }
                }
            }, index * 800);
        });

        setTimeout(() => {
            endTurn();
        }, (ai.board.length + 1) * 800);
    }, 1000);
}

// ===== WIN CONDITION =====

function checkWinCondition() {
    if (game.player.health <= 0) {
        showGameOver('Enemy Wins!');
    } else if (game.enemy.health <= 0) {
        showGameOver('You Win!');
    }
}

function showGameOver(message) {
    const modal = document.createElement('div');
    modal.className = 'game-info';
    modal.innerHTML = `
        <h2>${message}</h2>
        <p>Game Over</p>
        <div style="display: flex; gap: 20px; justify-content: center;">
            <button onclick="this.closest('.game-info').remove()">Keep Playing</button>
            <button onclick="location.reload()">Play Again</button>
        </div>
    `;
    modal.id = 'gameOverModal';
    document.body.appendChild(modal);
}

// ===== UI UPDATES =====

function updateUI() {
    // Update heroes
    document.getElementById('playerHealth').textContent = game.player.health;
    document.getElementById('enemyHealth').textContent = game.enemy.health;

    if (game.player.hero) {
        const playerLordName = document.querySelector('#playerLord .lord-name');
        if (playerLordName) playerLordName.textContent = game.player.hero.name;
        const playerCommand = document.getElementById('playerCommand');
        const playerWeaponCommand = document.getElementById('playerWeaponCommand');

        if (playerCommand) {
            const commandTitle = playerCommand.querySelector('.command-title');
            const commandCost = playerCommand.querySelector('.command-cost');

            // Always show hero ability power
            if (commandTitle) {
                commandTitle.textContent = game.player.hero.commandName || 'Command';
            }
            if (commandCost) {
                const cost = game.player.hero.commandCost || game.player.hero.heroPowerCost || 2;
                commandCost.textContent = `${cost} Gold`;
            }

            // Check if afford able
            const cost = game.player.hero.commandCost || game.player.hero.heroPowerCost || 2;
            const canAfford = game.player.currentEssence >= cost;

            // Disable if already used or not player's turn
            const isDisabled = game.player.heroPowerUsed || game.currentPlayer !== 'player';
            const isNotAffordable = !canAfford && game.currentPlayer === 'player' && !game.player.heroPowerUsed;

            playerCommand.classList.toggle('disabled', isDisabled);
            playerCommand.classList.toggle('not-affordable', isNotAffordable);
        }

        // Handle weapon attack button separately
        const weapon = (game.player.equipmentSlots && game.player.equipmentSlots.weapon) || game.player.equipment;
        if (playerWeaponCommand) {
            if (weapon) {
                playerWeaponCommand.style.display = '';
                const weaponTitle = playerWeaponCommand.querySelector('.command-title');
                if (weaponTitle) weaponTitle.textContent = `${weapon.name} Attack`;

                const isDisabled = game.player.equipmentUsed || game.currentPlayer !== 'player';
                playerWeaponCommand.classList.toggle('disabled', isDisabled);
            } else {
                playerWeaponCommand.style.display = 'none';
            }
        }
    }

    if (game.enemy.hero) {
        const enemyLordName = document.querySelector('#enemyLord .lord-name');
        if (enemyLordName) enemyLordName.textContent = game.enemy.hero.name;
    }
    
    // Add equipment attack click handler to player hero portrait
    const playerLord = document.getElementById('playerLord');
    if (playerLord) {
        // Remove old handlers
        playerLord.onclick = null;
        
        // Add new handler if weapon is available
        const weapon = (game.player.equipmentSlots && game.player.equipmentSlots.weapon) || game.player.equipment;
        if (weapon && !game.player.equipmentUsed && game.currentPlayer === 'player') {
            playerLord.classList.add('equipped');
            playerLord.onclick = () => {
                useEquipmentAttack('player');
            };
        } else {
            playerLord.classList.remove('equipped');
        }
    }
    
    // Update hero attack display
    updateHeroAttackDisplay('player');
    updateHeroAttackDisplay('enemy');
    
    // Update equipment slots display
    updateEquipmentSlots('player');
    updateEquipmentSlots('enemy');
    
    // Update equipment display (small box like gold) - legacy support
    const equipmentDisplay = document.getElementById('equipmentDisplay');
    if (equipmentDisplay) {
        const weapon = (game.player.equipmentSlots && game.player.equipmentSlots.weapon) || game.player.equipment;
        if (weapon) {
            equipmentDisplay.innerHTML = `
                <div class="equipment-name">${weapon.name}</div>
                <div class="equipment-stats">‚öîÔ∏è${weapon.attackPower || 2}</div>
            `;
            equipmentDisplay.style.display = 'flex';
        } else {
            equipmentDisplay.style.display = 'none';
        }
    }

    // Update essence/gold
    updateEssenceDisplay('player');
    updateEssenceDisplay('enemy');

    // Update deck counts (if elements exist)
    const playerDeckCount = document.getElementById('playerDeckCount');
    if (playerDeckCount) playerDeckCount.textContent = game.player.deck.length;
    const enemyDeckCount = document.getElementById('enemyDeckCount');
    if (enemyDeckCount) enemyDeckCount.textContent = game.enemy.deck.length;
    const enemyHandCount = document.getElementById('enemyHandCount');
    if (enemyHandCount) enemyHandCount.textContent = game.enemy.hand.length;

    // Update boards
    updateBoard('player');
    updateBoard('enemy');

    // Update hand
    updateHand();

    // Update enemy hand display
    updateEnemyHandDisplay();
    
    // Show/hide end turn button based on current player
    const endTurnBtn = document.getElementById('endTurnBtn');
    if (endTurnBtn) {
        if (game.currentPlayer === 'player') {
            endTurnBtn.classList.remove('hidden');
        } else {
            endTurnBtn.classList.add('hidden');
        }
    }
}


function updateHeroAttackDisplay(player) {
    const lordId = player === 'player' ? 'playerLord' : 'enemyLord';
    const lordEl = document.getElementById(lordId);
    const playerData = player === 'player' ? game.player : game.enemy;

    if (!lordEl) return;

    const existingAttack = lordEl.querySelector('.lord-attack');
    if (existingAttack) existingAttack.remove();

    const weapon = (playerData.equipmentSlots && playerData.equipmentSlots.weapon) || playerData.equipment;
    if (weapon) {
        const attackDisplay = document.createElement('div');
        attackDisplay.className = 'lord-attack';
        attackDisplay.innerHTML = `‚öîÔ∏è <span>${weapon.attackPower || 2}</span>`;
        lordEl.appendChild(attackDisplay);
    }
}


function updateEquipmentSlots(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    const slotsContainer = document.getElementById(`${player}EquipmentSlots`);
    if (!slotsContainer) return;
    
    // Slot order: weapon, head, chest, legs, shield, boots
    const slotOrder = ['weapon', 'head', 'chest', 'legs', 'shield', 'boots'];
    slotsContainer.innerHTML = '';
    
    slotOrder.forEach(slotName => {
        const slot = document.createElement('div');
        slot.className = 'equipment-slot';
        slot.setAttribute('data-slot', slotName);
        
        const equip = playerData.equipmentSlots[slotName];
        if (equip) {
            slot.classList.add('filled');
            if (equip.armorValue) {
                slot.title = `${equip.name} (+${equip.armorValue} HP)`;
            } else {
                slot.title = `${equip.name} (‚öîÔ∏è${equip.attackPower || 2})`;
            }
        } else {
            slot.title = `${slotName} (empty)`;
        }
        
        slotsContainer.appendChild(slot);
    });
}

function updateEssenceDisplay(player) {
    const playerData = player === 'player' ? game.player : game.enemy;
    const goldText = document.getElementById(`${player}Gold`);
    const goldCoinsContainer = document.getElementById(`${player}GoldCoins`);

    if (goldText) {
        goldText.textContent = `${playerData.currentEssence}/${playerData.maxEssence}`;
    }

    if (goldCoinsContainer) {
        goldCoinsContainer.innerHTML = '';
        for (let i = 0; i < playerData.maxEssence; i++) {
            const coin = document.createElement('div');
            coin.className = 'gold-coin';
            if (i >= playerData.currentEssence) {
                coin.classList.add('spent');
            }
            goldCoinsContainer.appendChild(coin);
        }
    }
}

function updateBoard(player) {
    const board = document.getElementById(`${player}Board`);
    if (!board) return;

    const playerData = player === 'player' ? game.player : game.enemy;

    board.innerHTML = '';

    playerData.board.forEach(construct => {
        const cardEl = createCardElement(construct, player, true);
        cardEl.classList.add('card-enter-animation');
        board.appendChild(cardEl);
    });
}

// Hand scrolling state
let handScrollOffset = 0;
const CARDS_VISIBLE = 5;

function updateHand() {
    const hand = document.getElementById('playerHand');
    hand.innerHTML = '';

    game.player.hand.forEach((card, index) => {
        const cardEl = createCardElement(card, 'player', false);
        // Add draw animation to newly drawn cards
        if (card.justDrawn) {
            cardEl.classList.add('card-draw-animation');
            delete card.justDrawn; // Remove flag after animation
        }

        // No backdrop needed - card just zooms

        hand.appendChild(cardEl);
    });

    // Reset scroll to beginning when hand updates
    resetHandScroll();

    // Update scroll button visibility and positioning
    updateHandScroll();
}

function updateHandScroll() {
    const handCount = game.player.hand.length;
    const prevBtn = document.getElementById('handPrevBtn');
    const nextBtn = document.getElementById('handNextBtn');
    const hand = document.getElementById('playerHand');

    if (!prevBtn || !nextBtn || !hand) return;

    if (handCount > CARDS_VISIBLE) {
        // Ensure offset is within bounds
        const maxOffset = handCount - CARDS_VISIBLE;
        handScrollOffset = Math.max(0, Math.min(handScrollOffset, maxOffset));

        // Show/hide buttons based on position
        prevBtn.classList.toggle('visible', handScrollOffset > 0);
        nextBtn.classList.toggle('visible', handScrollOffset < maxOffset);

        // Calculate scroll position: each card is 140px + 8px gap = 148px per offset
        const cardWidth = 90; // Card width
        const gap = 3; // Gap between cards
        const scrollAmount = handScrollOffset * (cardWidth + gap);
        hand.style.transform = `translateX(-${scrollAmount}px)`;
    } else {
        // Hide buttons if 5 or fewer cards
        prevBtn.classList.remove('visible');
        nextBtn.classList.remove('visible');
        hand.style.transform = 'translateX(0)';
        handScrollOffset = 0;
    }
}

function scrollHandPrev() {
    if (handScrollOffset > 0) {
        handScrollOffset--;
        updateHandScroll();
    }
}

function scrollHandNext() {
    const handCount = game.player.hand.length;
    if (handScrollOffset < handCount - CARDS_VISIBLE) {
        handScrollOffset++;
        updateHandScroll();
    }
}

// Reset hand scroll when hand updates
function resetHandScroll() {
    handScrollOffset = 0;
}

function updateEnemyHandDisplay() {
    const enemyHandDisplay = document.getElementById('enemyHandDisplay');
    enemyHandDisplay.innerHTML = '';

    // Show card backs for enemy hand
    game.enemy.hand.forEach((card, index) => {
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back';
        cardBack.style.zIndex = index;
        enemyHandDisplay.appendChild(cardBack);
    });
}

function createCardElement(card, owner, onBoard) {
    const cardEl = document.createElement('div');
    cardEl.className = `card ${card.type}`;

    if (card.exhausted) {
        cardEl.classList.add('exhausted');
    }

    // Set card type class first
    const cardType = card.type === 'unit' ? 'unit' : (card.type === 'tactic' ? 'tactic' : (card.type === 'equipment' ? 'equipment' : card.type));
    cardEl.className = `card ${cardType}`;

    if (!onBoard && owner === 'player' && game.currentPlayer === 'player') {
        if (canPlayCard(card, 'player')) {
            cardEl.classList.add('can-play');
        }
    }

    // Highlight cards that can attack
    if (onBoard && owner === 'player' && game.currentPlayer === 'player' && card.canAttack && !card.exhausted) {
        cardEl.classList.add('can-attack');
    }
    
    // Store card data for tooltip and reference
    cardEl._cardData = card;
    
    // Compact card layout: Cost, Name on header, stats on bottom
    const hasStats = (card.type === 'construct' || card.type === 'unit');
    cardEl.innerHTML = `
        <div class="card-header">
            <div class="card-cost">${card.cost}</div>
            <div class="card-name">${card.unitType ? getUnitTypeIcon(card.unitType) + ' ' : ''}${card.name}${card.tier && card.tier > 1 ? ' T' + card.tier : ''}</div>
        </div>
        <div class="card-art-frame">
            <div class="card-art">${getCardArt(card)}</div>
        </div>
        <div class="card-text-box">
            <div class="card-text">${card.text || ''}</div>
        </div>
        ${hasStats ? `
            <div class="card-stats-footer">
                <div class="card-stat stat-power">‚öîÔ∏è${card.power}</div>
                <div class="card-stat stat-health">‚ù§Ô∏è${card.durability}</div>
            </div>
        ` : ''}
        ${card.keywords ? `<div class="card-type-badge">${card.keywords.join(', ')}</div>` : ''}
    `;
    
    // Add tooltip data attribute for description and effects (after innerHTML so it persists)
    if (!onBoard) {
        let tooltipText = card.text || '';
        if (card.keywords && card.keywords.length > 0) {
            tooltipText += '\n\nKeywords: ' + card.keywords.join(', ');
        }
        if (card.scoutEffect || card.commandEffect || card.dispatchEffect) {
            tooltipText += '\n\nEffect: Draw a card when played';
        }
        if (card.id === 'quiverRefill' || card.id === 'supplyLine' || card.id === 'courierNetwork') {
            tooltipText += '\n\nEffect: Draw 3 cards';
        }
        if (card.id && (card.id.includes('Enchantment') || card.id.includes('Mark') || card.id.includes('Formation') || card.id.includes('Wall'))) {
            tooltipText += '\n\nEffect: Buffs units or equipment';
        }
        if (tooltipText) {
            cardEl.setAttribute('data-description', tooltipText);
            cardEl.classList.add('card-tooltip');
        }
    }

    // Click handlers
    if (!onBoard && owner === 'player' && game.currentPlayer === 'player') {
        cardEl.onclick = () => handleCardPlay(card);
    } else if (onBoard && owner === 'player' && game.currentPlayer === 'player') {
        cardEl.onclick = () => handleConstructClick(card);
    }

    // Hand card hover - show preview in sidebar
    if (!onBoard && owner === 'player') {
        cardEl.addEventListener('mouseenter', () => {
            const preview = document.getElementById('handCardPreview');
            if (!preview) return;

            const hasStats = (card.type === 'construct' || card.type === 'unit');

            let statsHTML = '';
            if (hasStats) {
                statsHTML = `
                    <div class="preview-stats">
                        <div class="preview-stat">‚öîÔ∏è${card.power}</div>
                        <div class="preview-stat">‚ù§Ô∏è${card.durability}</div>
                        <div class="preview-stat">üí∞${card.cost}</div>
                    </div>
                `;
            } else {
                statsHTML = `<div class="preview-stats"><div class="preview-stat">üí∞${card.cost}</div></div>`;
            }

            let keywordsHTML = '';
            if (card.keywords && card.keywords.length > 0) {
                keywordsHTML = `<div class="preview-keywords"><strong>Keywords:</strong> ${card.keywords.join(', ')}</div>`;
            }

            const previewContent = preview.querySelector('.preview-content');
            previewContent.innerHTML = `
                <div class="card-name">${card.name}${card.tier && card.tier > 1 ? ' T' + card.tier : ''}</div>
                ${statsHTML}
                <div class="preview-text">${card.text || '(No description)'}</div>
                ${keywordsHTML}
            `;
        });

        cardEl.addEventListener('mouseleave', () => {
            const preview = document.getElementById('handCardPreview');
            if (preview) {
                const previewContent = preview.querySelector('.preview-content');
                previewContent.innerHTML = '';
            }
        });
    }

    // Store reference
    cardEl._cardData = card;

    // Add hover preview for battlefield cards
    if (onBoard) {
        cardEl.addEventListener('mouseenter', (e) => {
            showCardPreview(card, e);
        });
        cardEl.addEventListener('mouseleave', () => {
            hideCardPreview();
        });
        cardEl.addEventListener('mousemove', (e) => {
            updateCardPreviewPosition(e);
        });
    }

    return cardEl;
}

function getCardArt(card) {
    // Return emoji/icon based on card type and specific card
    if (card.type === 'construct') {
        // Different icons for different constructs
        if (card.id.includes('ember') || card.id.includes('ash')) return 'üî•';
        if (card.id.includes('frost') || card.id.includes('ice')) return '‚ùÑÔ∏è';
        if (card.id.includes('storm')) return '‚ö°';
        if (card.id.includes('iron') || card.id.includes('scrap')) return '‚öôÔ∏è';
        if (card.id.includes('essence')) return 'üí†';
        if (card.id.includes('quick') || card.id.includes('assassin')) return '‚öîÔ∏è';
        return 'ü§ñ'; // Default construct
    } else if (card.type === 'technique') {
        // Different icons for different spells
        if (card.id.includes('lightning') || card.id.includes('chain')) return '‚ö°';
        if (card.id.includes('meteor') || card.id.includes('strike')) return '‚òÑÔ∏è';
        if (card.id.includes('shatter') || card.id.includes('reality')) return 'üí•';
        if (card.id.includes('forge') || card.id.includes('burst')) return '‚ú®';
        return 'üåü'; // Default technique
    } else if (card.type === 'forge') {
        // Different icons for different equipment
        if (card.id.includes('blade') || card.id.includes('weapon')) return '‚öîÔ∏è';
        if (card.id.includes('armor') || card.id.includes('plate')) return 'üõ°Ô∏è';
        if (card.id.includes('conduit') || card.id.includes('essence')) return 'üíé';
        return 'üî®'; // Default equipment
    }
    return '‚ùì';
}

function getRaritySymbol(rarity) {
    switch (rarity) {
        case 'common': return '‚ö™';
        case 'rare': return 'üîµ';
        case 'epic': return 'üü£';
        case 'legendary': return 'üü°';
        default: return '';
    }
}

function handleCardPlay(card) {
    if (game.currentPlayer !== 'player') return;

    if (card.needsTarget || (card.targetType && card.targetType !== 'any')) {
        startTargeting(card);
    } else {
        playCard(card, 'player');
    }
}

function handleConstructClick(construct) {
    if (game.currentPlayer !== 'player') return;

    // Only handle attacking - spell targeting is now handled by startTargeting() click handlers
    if (!game.targeting) {
        // Attack with this construct
        if (construct.canAttack) {
            startAttacking(construct);
        }
    }
}

function startTargeting(card) {
    game.targeting = { card, mode: 'spell' };
    document.body.classList.add('targeting');
    log('Select a target for ' + card.name + '...', 'player');

    // Add visual highlights and click handlers to valid targets
    if (card.targetType === 'unit' || card.targetType === 'construct') {
        // Target enemy units/constructs
        const enemyBoard = document.getElementById('enemyBoard');
        if (enemyBoard) {
            const constructEls = enemyBoard.querySelectorAll('.card');
            constructEls.forEach(el => {
                if (el._cardData) {
                    el.classList.add('valid-target');
                    el.onclick = () => {
                        if (game.targeting && game.targeting.mode === 'spell') {
                            playCard(card, 'player', el._cardData);
                            cancelTargeting();
                        }
                    };
                }
            });
        }
    } else {
        // Can target any unit or hero
        const allBoards = ['enemyBoard', 'playerBoard'];
        allBoards.forEach(boardId => {
            const board = document.getElementById(boardId);
            if (board) {
                const constructEls = board.querySelectorAll('.card');
                constructEls.forEach(el => {
                    if (el._cardData) {
                        el.classList.add('valid-target');
                        el.onclick = () => {
                            if (game.targeting) {
                                if (game.targeting.mode === 'spell') {
                                    playCard(card, 'player', el._cardData);
                                    cancelTargeting();
                                } else if (game.targeting.mode === 'heropower') {
                                    useHeroPower('player', el._cardData);
                                    cancelTargeting();
                                }
                            }
                        };
                    }
                });
            }
        });

        // Also allow targeting heroes if applicable
        const enemyHero = document.getElementById('enemyLord');
        if (enemyHero) {
            enemyHero.classList.add('valid-target');
            enemyHero.onclick = () => {
                if (game.targeting) {
                    if (game.targeting.mode === 'spell') {
                        playCard(card, 'player', { type: 'hero', name: 'Enemy' });
                        cancelTargeting();
                    } else if (game.targeting.mode === 'heropower') {
                        useHeroPower('player', { type: 'hero', name: 'Enemy' });
                        cancelTargeting();
                    }
                }
            };
        }
    }

    // Don't call updateUI() here - it would remove our click handlers!
}

function startHeroPowerTargeting() {
    const hero = game.player.hero;
    if (!hero) return;

    document.body.classList.add('targeting');
    
    if (hero.id === 'warLord') {
        // Can target any unit or hero
        const allBoards = ['enemyBoard', 'playerBoard'];
        allBoards.forEach(boardId => {
            const board = document.getElementById(boardId);
            if (board) {
                const constructEls = board.querySelectorAll('.card');
                constructEls.forEach(el => {
                    if (el._cardData) {
                        el.classList.add('valid-target');
                        el.onclick = () => {
                            if (game.targeting && game.targeting.mode === 'heropower') {
                                useHeroPower('player', el._cardData);
                                cancelTargeting();
                            }
                        };
                    }
                });
            }
        });

        const enemyHero = document.getElementById('enemyLord');
        if (enemyHero) {
            enemyHero.classList.add('valid-target');
            enemyHero.onclick = () => {
                if (game.targeting && game.targeting.mode === 'heropower') {
                    useHeroPower('player', { type: 'hero', name: 'Enemy' });
                    cancelTargeting();
                }
            };
        }
    } else if (hero.id === 'mountainKing' || hero.id === 'swiftRider') {
        // Can only target friendly units
        const playerBoard = document.getElementById('playerBoard');
        if (playerBoard) {
            const constructEls = playerBoard.querySelectorAll('.card');
            constructEls.forEach(el => {
                if (el._cardData) {
                    el.classList.add('valid-target');
                    el.onclick = () => {
                        if (game.targeting && game.targeting.mode === 'heropower') {
                            useHeroPower('player', el._cardData);
                            cancelTargeting();
                        }
                    };
                }
            });
        }
    }
}

function startAttacking(attacker) {
    game.targeting = { attacker, mode: 'attack' };
    document.body.classList.add('targeting');
    log(`${attacker.name} ready to attack! Select target...`, 'player');

    // Highlight the attacking card
    const playerBoard = document.getElementById('playerBoard');
    playerBoard.querySelectorAll('.card').forEach(el => {
        if (el._cardData && el._cardData.instanceId === attacker.instanceId) {
            el.classList.add('attacking');
        }
    });

    // Check for guards/defend
    const guards = game.enemy.board.filter(c => 
        c.keywords && (c.keywords.includes('guard') || c.keywords.includes('defend'))
    );

    // Add click handler to enemy hero (if no guards)
    if (guards.length === 0) {
        const enemyHero = document.getElementById('enemyLord');
        enemyHero.classList.add('valid-target');
        enemyHero.onclick = () => {
            if (game.targeting && game.targeting.mode === 'attack') {
                attack(game.targeting.attacker, { name: 'Enemy' }, 'player');
                cancelTargeting();
            }
        };
    }

    // Add click handlers to enemy constructs
    const boardEl = document.getElementById('enemyBoard');
    if (boardEl) {
        const constructEls = boardEl.querySelectorAll('.card');
        constructEls.forEach(el => {
            const construct = el._cardData;
            if (construct) {
                // Only guards/defend can be targeted if they exist
                const hasGuard = construct.keywords && 
                    (construct.keywords.includes('guard') || construct.keywords.includes('defend'));
                if (guards.length === 0 || hasGuard) {
                    el.classList.add('valid-target');
                    el.onclick = () => {
                        if (game.targeting && game.targeting.mode === 'attack') {
                            attack(game.targeting.attacker, construct, 'player');
                            cancelTargeting();
                        }
                    };
                }
            }
        });
    }

    // Don't call updateUI() here - it would remove our click handlers!
}

function isValidTarget(target, card) {
    if (card.targetType === 'construct') {
        return target.type === 'construct';
    }
    return true;
}

function cancelTargeting() {
    game.targeting = null;
    document.body.classList.remove('targeting');

    // Remove all targeting highlights
    document.querySelectorAll('.valid-target').forEach(el => {
        el.classList.remove('valid-target');
        el.onclick = null;
    });

    document.querySelectorAll('.attacking').forEach(el => {
        el.classList.remove('attacking');
    });

    const enemyLord = document.getElementById('enemyLord');
    if (enemyLord) {
        enemyLord.onclick = null;
        enemyLord.classList.remove('valid-target');
    }

    updateUI();
}

// ===== EVENT LISTENERS =====

document.getElementById('endTurnBtn').onclick = () => {
    if (game.currentPlayer === 'player') {
        endTurn();
    }
};

const playerCommandEl = document.getElementById('playerCommand');
if (playerCommandEl) {
    playerCommandEl.onclick = () => {
        if (game.currentPlayer === 'player' && game.player.hero && !game.player.heroPowerUsed) {
            // Use hero power/ability
            const hero = game.player.hero;
            if (hero.commandText && hero.commandText.includes('target')) {
                // Needs a target
                startTargeting({ ...hero, type: 'heropower', needsTarget: true });
            } else {
                // Direct hero power (usually deals damage or has effect)
                useHeroPower('player');
            }
        }
    };
}

const playerWeaponCommandEl = document.getElementById('playerWeaponCommand');
if (playerWeaponCommandEl) {
    playerWeaponCommandEl.onclick = () => {
        if (game.currentPlayer === 'player' && !game.player.equipmentUsed) {
            useEquipmentAttack('player');
        }
    };
}

// Cursor trail for targeting
let cursorGlowElement = null;
let trailCounter = 0;

document.addEventListener('mousemove', (e) => {
    if (!document.body.classList.contains('targeting')) {
        // Remove glow if not targeting
        if (cursorGlowElement) {
            cursorGlowElement.remove();
            cursorGlowElement = null;
        }
        return;
    }

    // Create or update cursor glow
    if (!cursorGlowElement) {
        cursorGlowElement = document.createElement('div');
        cursorGlowElement.className = 'cursor-glow player-glow';
        document.body.appendChild(cursorGlowElement);
    }
    cursorGlowElement.style.left = e.clientX + 'px';
    cursorGlowElement.style.top = e.clientY + 'px';

    // Create trail particles every few pixels
    trailCounter++;
    if (trailCounter % 3 === 0) {
        const trail = document.createElement('div');
        trail.className = 'cursor-trail player-trail';
        trail.style.width = '15px';
        trail.style.height = '15px';
        trail.style.left = (e.clientX - 7.5) + 'px';
        trail.style.top = (e.clientY - 7.5) + 'px';
        document.body.appendChild(trail);

        // Remove trail particle after animation completes
        setTimeout(() => {
            trail.remove();
        }, 600);
    }
});

// Clean up cursor glow when targeting ends
const originalCancelTargeting = cancelTargeting;
cancelTargeting = function() {
    originalCancelTargeting();
    if (cursorGlowElement) {
        cursorGlowElement.remove();
        cursorGlowElement = null;
    }
};

// Card Preview Functions
let cardPreviewEl = null;

function showCardPreview(card, event) {
    // Create preview element if it doesn't exist
    if (!cardPreviewEl) {
        cardPreviewEl = document.createElement('div');
        cardPreviewEl.className = 'card-preview';
        document.body.appendChild(cardPreviewEl);
    }

    // Build preview content
    const hasStats = (card.type === 'construct' || card.type === 'unit');
    cardPreviewEl.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <span style="font-size: 24px; font-weight: bold; color: #ffd700;">${card.name}</span>
            <div style="background: radial-gradient(circle, #d4af37 0%, #aa8b2c 100%); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #fff; font-size: 18px;">${card.cost}</div>
        </div>
        ${hasStats ? `
            <div style="display: flex; gap: 10px; margin-bottom: 12px;">
                <div style="background: radial-gradient(circle, #ff6b35 0%, #c41e3a 100%); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #fff; font-size: 18px;">‚öîÔ∏è${card.power}</div>
                <div style="background: radial-gradient(circle, #4ecdc4 0%, #2d8b85 100%); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #fff; font-size: 18px;">‚ù§Ô∏è${card.durability}</div>
            </div>
        ` : ''}
        <div style="font-size: 26px; line-height: 1.6; color: #f4e4c1; flex: 1;">${card.text || ''}</div>
        ${card.keywords ? `<div style="font-size: 16px; color: #d4af37; margin-top: 10px;"><strong>Keywords:</strong> ${card.keywords.join(', ')}</div>` : ''}
    `;

    cardPreviewEl.classList.add('visible');
    updateCardPreviewPosition(event);
}

function hideCardPreview() {
    if (cardPreviewEl) {
        cardPreviewEl.classList.remove('visible');
    }
}

function updateCardPreviewPosition(event) {
    if (!cardPreviewEl) return;
    const padding = 15;
    let left = event.clientX + padding;
    let top = event.clientY + padding;

    // Adjust if preview goes off-screen
    if (left + 240 > window.innerWidth) {
        left = event.clientX - 240 - padding;
    }
    if (top + 340 > window.innerHeight) {
        top = event.clientY - 340 - padding;
    }

    cardPreviewEl.style.left = left + 'px';
    cardPreviewEl.style.top = top + 'px';
}

// Right-click to cancel
document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (game.targeting) {
        cancelTargeting();
        log('Targeting cancelled');
    }
});


// COMPATIBILITY: Use HISTORIC_LEADERS and CARD_DATABASE from lords-of-war.js
// This runs after lords-of-war.js has loaded
function initializeGameData() {
    // HISTORIC_LEADERS and CARD_DATABASE are already on window from lords-of-war.js
    // No need to reassign - just use window.HISTORIC_LEADERS and window.CARD_DATABASE
    
    // Ensure functions are available globally (replace the stubs with real functions)
    if (typeof window !== 'undefined') {
        window.startGame = startGame;
        window.chooseUnitType = chooseUnitType;
        window.selectHero = selectHero;
        window.showUnitTypeSelection = showUnitTypeSelection;
        
        // Initialize modal on page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                if (typeof showUnitTypeSelection === 'function') {
                    showUnitTypeSelection();
                }
            });
        } else {
            if (typeof showUnitTypeSelection === 'function') {
                showUnitTypeSelection();
            }
        }
    }
}

// Initialize when script loads (after lords-of-war.js)
if (typeof window !== 'undefined') {
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeGameData);
    } else {
        // Scripts load synchronously, so wait a tick
        setTimeout(initializeGameData, 0);
    }
}
